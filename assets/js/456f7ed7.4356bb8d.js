"use strict";(self.webpackChunkbee_docs=self.webpackChunkbee_docs||[]).push([[556],{3905:function(e,t,n){n.d(t,{Zo:function(){return c},kt:function(){return p}});var r=n(7294);function a(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function o(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);t&&(r=r.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,r)}return n}function s(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?o(Object(n),!0).forEach((function(t){a(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):o(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function i(e,t){if(null==e)return{};var n,r,a=function(e,t){if(null==e)return{};var n,r,a={},o=Object.keys(e);for(r=0;r<o.length;r++)n=o[r],t.indexOf(n)>=0||(a[n]=e[n]);return a}(e,t);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(r=0;r<o.length;r++)n=o[r],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(a[n]=e[n])}return a}var d=r.createContext({}),l=function(e){var t=r.useContext(d),n=t;return e&&(n="function"==typeof e?e(t):s(s({},t),e)),n},c=function(e){var t=l(e.components);return r.createElement(d.Provider,{value:t},e.children)},h="mdxType",u={inlineCode:"code",wrapper:function(e){var t=e.children;return r.createElement(r.Fragment,{},t)}},f=r.forwardRef((function(e,t){var n=e.components,a=e.mdxType,o=e.originalType,d=e.parentName,c=i(e,["components","mdxType","originalType","parentName"]),h=l(n),f=a,p=h["".concat(d,".").concat(f)]||h[f]||u[f]||o;return n?r.createElement(p,s(s({ref:t},c),{},{components:n})):r.createElement(p,s({ref:t},c))}));function p(e,t){var n=arguments,a=t&&t.mdxType;if("string"==typeof e||a){var o=n.length,s=new Array(o);s[0]=f;var i={};for(var d in t)hasOwnProperty.call(t,d)&&(i[d]=t[d]);i.originalType=e,i[h]="string"==typeof e?e:a,s[1]=i;for(var l=2;l<o;l++)s[l]=n[l];return r.createElement.apply(null,s)}return r.createElement.apply(null,n)}f.displayName="MDXCreateElement"},4504:function(e,t,n){n.r(t),n.d(t,{assets:function(){return c},contentTitle:function(){return d},default:function(){return p},frontMatter:function(){return i},metadata:function(){return l},toc:function(){return h}});var r=n(7462),a=n(3366),o=(n(7294),n(3905)),s=["components"],i={title:"DISC",id:"disc"},d=void 0,l={unversionedId:"learn/technology/disc",id:"learn/technology/disc",title:"DISC",description:"DISC (Distributed Immutable Storage of Chunks) is a storage solution developed by Swarm based on a modified implementation of a Kademlia DHT which has been specialized for data storage. DHTs are commonly used by decentralized p2p networks to store content ids mapped to a list of seeders who are able to serve that content. Swarm's implementation of a DHT differs significantly in that it stores the content in the DHT directly, rather than just storing a list of seeders who are able to serve the content. This approach allows for much faster and more efficient retrieval of data.",source:"@site/docs/learn/technology/DISC.md",sourceDirName:"learn/technology",slug:"/learn/technology/disc",permalink:"/docs/learn/technology/disc",draft:!1,editUrl:"https://github.com/ethersphere/docs.github.io/blob/master/docs/learn/technology/DISC.md",tags:[],version:"current",frontMatter:{title:"DISC",id:"disc"},sidebar:"learn",previous:{title:"Kademlia",permalink:"/docs/learn/technology/kademlia"},next:{title:"Incentives",permalink:"/docs/learn/technology/incentives"}},c={},h=[{value:"Chunks",id:"chunks",level:3},{value:"Content-Addressed Chunks and Single-Owner Chunks",id:"content-addressed-chunks-and-single-owner-chunks",level:3}],u={toc:h},f="wrapper";function p(e){var t=e.components,n=(0,a.Z)(e,s);return(0,o.kt)(f,(0,r.Z)({},u,n,{components:t,mdxType:"MDXLayout"}),(0,o.kt)("p",null,"DISC (Distributed Immutable Storage of Chunks) is a storage solution developed by Swarm based on a modified implementation of a ",(0,o.kt)("a",{parentName:"p",href:"/docs/learn/technology/kademlia"},"Kademlia DHT")," which has been specialized for data storage. DHTs are commonly used by decentralized p2p networks to store content ids mapped to a list of seeders who are able to serve that content. Swarm's implementation of a DHT differs significantly in that it stores the content in the DHT directly, rather than just storing a list of seeders who are able to serve the content. This approach allows for much faster and more efficient retrieval of data."),(0,o.kt)("h3",{id:"chunks"},"Chunks"),(0,o.kt)("p",null,"In the DISC model, chunks are the canonical unit of data. When a file is uploaded to Swarm, it gets broken down into 4kb pieces with attached metadata. The pieces then get distributed amongst nodes in the Swarm network based on their ",(0,o.kt)("a",{parentName:"p",href:"/docs/learn/glossary#overlay"},"overlay addresses"),". There are two fundamental chunk types: content-addressed chunks and single-owner chunks. "),(0,o.kt)("h3",{id:"content-addressed-chunks-and-single-owner-chunks"},"Content-Addressed Chunks and Single-Owner Chunks"),(0,o.kt)("p",null,"Content-addressed chunks are chunks whose address is based on the hash digest of their data. Using a hash as the chunk address makes it possible to verify the integrity of chunk data. Swarm uses the BMT hash function based on a binary Merkle tree over small segments of the chunk data. A content-addressed chunk has an at most 4KB payload, and its address is calculated as the hash of the span (chunk metadata) and the Binary Merkle Tree hash of the payload."),(0,o.kt)("p",null,"Single-owner chunks, on the other hand, are owned by a single owner and can be updated only by that owner. The address is calculated as the hash of a unique id and the owner's overlay address. The content consists of an arbitrary data payload along with required headers."),(0,o.kt)("p",null,"The main difference between content-addressed chunks and single-owner chunks lies in their ownership model. Content-addressed chunks are immutable and cannot be updated even by their original uploader, while single-owner chunks can be updated by their owner."),(0,o.kt)("p",null,"Content-addressed chunks are useful for storing immutable data such as public documents or media files that do not need to be updated frequently. They are also useful for verifying the integrity of data, as the hash of the data can be used to verify that it has not been tampered with."),(0,o.kt)("p",null,"Single-owner chunks, on the other hand, are useful for storing data that needs to be updated frequently or that needs to be kept private. They are owned by a single user and can be updated only by that user."))}p.isMDXComponent=!0}}]);