"use strict";(self.webpackChunkbee_docs=self.webpackChunkbee_docs||[]).push([[6572],{3905:function(e,t,a){a.d(t,{Zo:function(){return c},kt:function(){return p}});var n=a(7294);function r(e,t,a){return t in e?Object.defineProperty(e,t,{value:a,enumerable:!0,configurable:!0,writable:!0}):e[t]=a,e}function i(e,t){var a=Object.keys(e);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(e);t&&(n=n.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),a.push.apply(a,n)}return a}function o(e){for(var t=1;t<arguments.length;t++){var a=null!=arguments[t]?arguments[t]:{};t%2?i(Object(a),!0).forEach((function(t){r(e,t,a[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(a)):i(Object(a)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(a,t))}))}return e}function s(e,t){if(null==e)return{};var a,n,r=function(e,t){if(null==e)return{};var a,n,r={},i=Object.keys(e);for(n=0;n<i.length;n++)a=i[n],t.indexOf(a)>=0||(r[a]=e[a]);return r}(e,t);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(n=0;n<i.length;n++)a=i[n],t.indexOf(a)>=0||Object.prototype.propertyIsEnumerable.call(e,a)&&(r[a]=e[a])}return r}var l=n.createContext({}),d=function(e){var t=n.useContext(l),a=t;return e&&(a="function"==typeof e?e(t):o(o({},t),e)),a},c=function(e){var t=d(e.components);return n.createElement(l.Provider,{value:t},e.children)},u="mdxType",h={inlineCode:"code",wrapper:function(e){var t=e.children;return n.createElement(n.Fragment,{},t)}},m=n.forwardRef((function(e,t){var a=e.components,r=e.mdxType,i=e.originalType,l=e.parentName,c=s(e,["components","mdxType","originalType","parentName"]),u=d(a),m=r,p=u["".concat(l,".").concat(m)]||u[m]||h[m]||i;return a?n.createElement(p,o(o({ref:t},c),{},{components:a})):n.createElement(p,o({ref:t},c))}));function p(e,t){var a=arguments,r=t&&t.mdxType;if("string"==typeof e||r){var i=a.length,o=new Array(i);o[0]=m;var s={};for(var l in t)hasOwnProperty.call(t,l)&&(s[l]=t[l]);s.originalType=e,s[u]="string"==typeof e?e:r,o[1]=s;for(var d=2;d<i;d++)o[d]=a[d];return n.createElement.apply(null,o)}return n.createElement.apply(null,a)}m.displayName="MDXCreateElement"},5:function(e,t,a){a.r(t),a.d(t,{assets:function(){return c},contentTitle:function(){return l},default:function(){return p},frontMatter:function(){return s},metadata:function(){return d},toc:function(){return u}});var n=a(7462),r=a(3366),i=(a(7294),a(3905)),o=["components"],s={title:"Kademlia",id:"kademlia"},l=void 0,d={unversionedId:"learn/technology/kademlia",id:"learn/technology/kademlia",title:"Kademlia",description:"What is Kademlia?",source:"@site/docs/learn/technology/kademlia.md",sourceDirName:"learn/technology",slug:"/learn/technology/kademlia",permalink:"/docs/learn/technology/kademlia",draft:!1,editUrl:"https://github.com/ethersphere/docs.github.io/blob/master/docs/learn/technology/kademlia.md",tags:[],version:"current",frontMatter:{title:"Kademlia",id:"kademlia"},sidebar:"learn",previous:{title:"What is Swarm?",permalink:"/docs/learn/technology/what-is-swarm"},next:{title:"DISC",permalink:"/docs/learn/technology/disc"}},c={},u=[{value:"What is Kademlia?",id:"what-is-kademlia",level:3},{value:"Kademlia Distance",id:"kademlia-distance",level:3},{value:"How Swarm Uses Kademlia",id:"how-swarm-uses-kademlia",level:2}],h={toc:u},m="wrapper";function p(e){var t=e.components,a=(0,r.Z)(e,o);return(0,i.kt)(m,(0,n.Z)({},h,a,{components:t,mdxType:"MDXLayout"}),(0,i.kt)("h3",{id:"what-is-kademlia"},"What is Kademlia?"),(0,i.kt)("p",null,'Kademlia is a distributed hash table (DHT) for decentralized peer-to-peer computer networks, which is designed to provide a more efficient and scalable means for node lookup and data storage across a distributed system. It was introduced by Petar Maymounkov and David Mazi\xe8res in 2002 in a paper titled "Kademlia: A Peer-to-peer Information System Based on the XOR Metric." A version of Kademlia which has been specialized for data storage forms the basis of Swarm\'s ',(0,i.kt)("a",{parentName:"p",href:"/docs/learn/technology/DISC"},"DISC storage model"),"."),(0,i.kt)("h3",{id:"kademlia-distance"},"Kademlia Distance"),(0,i.kt)("p",null,'Kademlia distance is a metric used to measure the "closeness" between nodes in a peer-to-peer network. Note Kademlia distance has no relation to geographical distance. Nodes which have a very small Kademlia distance may be very far from each other geographically. The distance is calculated using the bitwise exclusive or (XOR) operation on the node identifiers (IDs) and is crucial for organizing and searching the network efficiently.'),(0,i.kt)("p",null,"Node IDs are typically generated using a cryptographic hash function, resulting in a large fixed-size bit string (e.g., 160 bits for the original Kademlia implementation). To calculate the Kademlia distance between two nodes, their IDs are XOR'd bitwise, and the resulting bit string is treated as an integer. The integer value represents the distance between the nodes in the Kademlia DHT."),(0,i.kt)("p",null,"By using this distance metric, Kademlia can quickly and efficiently locate nodes or data within the distributed network. When searching for a node or a piece of data, the algorithm proceeds iteratively, querying the closest known nodes to the target ID and refining the search with each iteration until the target is found."),(0,i.kt)("p",null,"Kademlia relies on a unique distance metric based on the XOR operation (exclusive or) to organize nodes and data within the network. This metric provides several benefits, such as:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"Deterministic and symmetric: The distance between any two nodes remains the same, regardless of which node is measuring it."),(0,i.kt)("li",{parentName:"ul"},"Unidirectional: The distance between two nodes doesn't change based on their position in the network."),(0,i.kt)("li",{parentName:"ul"},"High probability of unique distances: The XOR metric ensures a low probability of collisions, resulting in a more even distribution of nodes.")),(0,i.kt)("p",null,'In Kademlia, each node has a unique identifier (ID), typically generated from a cryptographic hash function. Nodes are organized into a binary tree-like structure called a "k-bucket" system, where each bucket contains nodes with a certain range of distances from the node. As the distance from the node increases, the size of the range covered by each bucket grows.'),(0,i.kt)("p",null,"Kademlia uses an iterative lookup algorithm for node and data lookups. When a node wants to find another node or data, it starts by querying the closest known nodes to the target ID. These nodes, in turn, respond with information about the closest nodes they know, and the process continues until the target node or data is found."),(0,i.kt)("p",null,"Kademlia has been used as the basis for various peer-to-peer applications, including the BitTorrent protocol's Distributed Hash Table (DHT) and the Ethereum network's node discovery protocol."),(0,i.kt)("h2",{id:"how-swarm-uses-kademlia"},"How Swarm Uses Kademlia"),(0,i.kt)("p",null,"While Kadamlia and other DHTs are commonly used by decentralized data storage networks, they typically are used only for storing references to where the data is stored. Swarm's implementation differs in that the data is broken into chunks and stored in the Kademlia DHT itself. Swarm uses Kademlia as a key building block of its DISC storage model. For more details, see the ",(0,i.kt)("a",{parentName:"p",href:"/docs/learn/technology/DISC"},"DISC")," section."))}p.isMDXComponent=!0}}]);